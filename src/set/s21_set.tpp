namespace s21 {

/**
 * @brief Создает пустой контейнер типа set.
 *
 * Конструктор инициализирует пустой экземпляр контейнера типа set. Внутренняя
 * структура данных, представляющая дерево красно-черного типа, инициализируется
 * через создание нового экземпляра tree_type с помощью оператора new.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 */
template <typename Key> set<Key>::set() : tree_(new tree_type{}) {}

/**
 * @brief Конструктор множества на основе списка инициализации.
 *
 * Этот конструктор создает множество на основе переданного списка
 * инициализации. Дублирующиеся элементы игнорируются, и только уникальные
 * элементы добавляются в множество.
 *
 * @param items Список инициализации элементами для создания множества.
 */
template <typename Key>
set<Key>::set(std::initializer_list<value_type> const &items) : set() {
  for (auto item : items) {
    // Проверяем, содержится ли элемент уже в множестве
    if (!contains(item)) {
      // Если элемента нет, вставляем его в множество
      insert(item);
    }
  }
}

/**
 * @brief Создает копию контейнера типа set из другого контейнера.
 *
 * Этот конструктор создает новый экземпляр контейнера типа set и заполняет его
 * элементами из другого существующего контейнера типа set. Внутренняя структура
 * данных, представляющая дерево красно-черного типа, также инициализируется.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param other Ссылка на другой контейнер типа set, из которого выполняется
 * копирование.
 */
template <typename Key> set<Key>::set(const set &other) : set() {
  // Проверка на самоприсваивание
  if (this != &other) {
    // Копирование содержимого дерева из другого контейнера
    *tree_ = *other.tree_;
  }
}
/**
 * @brief Конструктор перемещения для контейнера типа set.
 *
 * Этот конструктор перемещает содержимое другого контейнера типа set
 * в текущий экземпляр контейнера с использованием семантики перемещения.
 * Внутренняя структура данных, представляющая дерево красно-черного типа,
 * также перемещается.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param other Контейнер, из которого будет перемещено содержимое.
 */
template <typename Key>
set<Key>::set(set &&other) noexcept
    : tree_(new tree_type(std::move(*other.tree_))) {}

/**
 * @brief Присваивание контейнера с использованием оператора присваивания.
 *
 * Этот метод выполняет операцию присваивания для контейнера типа set. В случае,
 * если присваивание происходит на самого себя (self-assignment), метод
 * предусматривает защиту от лишних операций и ненужных выделений памяти.
 * Сначала существующие элементы в текущем контейнере удаляются, а затем
 * копируются элементы из другого контейнера с использованием оператора
 * присваивания внутреннего дерева.
 *
 * @param other Контейнер типа set, из которого копируются элементы.
 * @return Ссылка на текущий экземпляр контейнера после присваивания.
 */
template <typename Key> set<Key> &set<Key>::operator=(const set &other) {
  // Проверка на self-assignment
  if (this != &other) {
    // Очищаем текущий контейнер
    tree_->Clear();
    // Копируем элементы из другого контейнера
    *tree_ = *other.tree_;
  }
  return *this;
}

/**
 * @brief Присваивает содержимое rvalue-контейнера типа set данному контейнеру.
 *
 * Этот оператор присваивания переносит содержимое rvalue-контейнера типа set
 * в текущий контейнер. Если контейнеры не совпадают (this != &other),
 * происходит обмен внутренних структур данных между контейнерами.
 * Это позволяет эффективно перенести ресурсы между контейнерами без
 * копирования.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param other Rvalue-контейнер, из которого будет произведено перемещение.
 * @return Ссылка на текущий контейнер после перемещения.
 */
template <typename Key> set<Key> &set<Key>::operator=(set &&other) noexcept {
  // Проверяем, что контейнеры не совпадают
  if (this != &other) {
    // Обмениваем внутренние структуры данных между контейнерами
    std::swap(tree_, other.tree_);
  }
  return *this;
}

/**
 * @brief Деструктор контейнера типа set.
 *
 * Деструктор освобождает выделенную память для внутренней структуры данных
 * (красно-черное дерево), если она была создана. Это происходит путем
 * удаления указателя на объект дерева и установки его в nullptr.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 */
template <typename Key> set<Key>::~set() {
  // Проверяем, было ли создано дерево
  if (tree_) {
    // Освобождаем память и устанавливаем указатель в nullptr
    delete tree_;
    tree_ = nullptr;
  }
}

/**
 * @brief Возвращает итератор, указывающий на начало контейнера.
 *
 * Этот метод возвращает итератор, который указывает на начало контейнера типа
 * set. Итератор получен путем вызова метода Begin() внутренней структуры данных
 * - дерева красно-черного типа.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @return Итератор, указывающий на начало контейнера.
 */
template <typename Key> typename set<Key>::iterator set<Key>::begin() noexcept {
  return tree_->Begin();
}

/**
 * @brief Возвращает константный итератор, указывающий на начало контейнера.
 *
 * Этот метод возвращает константный итератор, который указывает на начало
 * контейнера типа set. Итератор получен путем вызова метода Begin() внутренней
 * структуры данных - дерева красно-черного типа.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @return Константный итератор, указывающий на начало контейнера.
 */
template <typename Key>
typename set<Key>::const_iterator set<Key>::begin() const noexcept {
  return tree_->Begin();
}

/**
 * @brief Возвращает итератор, указывающий на конец контейнера.
 *
 * Этот метод возвращает итератор, указывающий на элемент за последним элементом
 * в контейнере. Итератор использует внутренний метод дерева красно-черного
 * типа, чтобы получить итератор, указывающий на конец контейнера.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @return Итератор, указывающий на конец контейнера.
 */
template <typename Key> typename set<Key>::iterator set<Key>::end() noexcept {
  return tree_->End();
}

/**
 * @brief Возвращает константный итератор, указывающий на конец контейнера.
 *
 * Этот метод возвращает константный итератор, указывающий на элемент за
 * последним элементом в контейнере. Итератор использует внутренний метод
 * дерева красно-черного типа, чтобы получить константный итератор, указывающий
 * на конец контейнера.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @return Константный итератор, указывающий на конец контейнера.
 */
template <typename Key>
typename set<Key>::const_iterator set<Key>::end() const noexcept {
  return tree_->End();
}

/**
 * @brief Проверяет, является ли контейнер пустым.
 *
 * Этот метод проверяет, содержит ли контейнер элементы, или он пуст.
 * Он использует внутреннюю структуру данных дерева красно-черного
 * типа для определения наличия элементов в контейнере.
 *
 * @return `true`, если контейнер пуст, `false` в противном случае.
 */
template <typename Key> inline bool set<Key>::empty() const noexcept {
  // Проверка, существует ли внутренняя структура данных
  // Если она существует, используем метод Empty() для определения пустоты
  // Если она не существует, считаем, что контейнер пуст
  return tree_ ? tree_->Empty() : true;
}

/**
 * @brief Получает текущий размер контейнера.
 *
 * Этот метод возвращает текущий размер (количество элементов) контейнера
 * типа set. Он использует метод Size() внутренней структуры данных,
 * представляющей дерево красно-черного типа, чтобы получить размер.
 * Если внутренняя структура данных не инициализирована (равна nullptr),
 * метод вернет 0.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @return Текущий размер контейнера.
 */
template <typename Key>
inline typename set<Key>::size_type set<Key>::size() const noexcept {
  // Проверяем, инициализирована ли внутренняя структура данных
  return tree_ ? tree_->Size() : 0;
}

/**
 * @brief Возвращает максимальное количество элементов, которое контейнер может
 * содержать.
 *
 * Этот метод возвращает максимальное количество элементов, которое контейнер
 * типа set может содержать. Он делегирует запрос к внутренней структуре данных
 * - дереву красно-черного типа. Если дерево не инициализировано, метод
 * возвращает значение, указывающее на отсутствие дерева (например, 0).
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @return Максимальное количество элементов, которое контейнер может содержать.
 */
template <typename Key>
typename set<Key>::size_type set<Key>::max_size() const noexcept {
  if (tree_) {
    // Возвращаем максимальное количество элементов из дерева
    return tree_->MaxSize();
  }
  // Если дерево не инициализировано, возвращаем значение, указывающее на
  // отсутствие дерева
  return 0; // или другое значение, которое бы обозначало отсутствие дерева
}

/**
 * @brief Очищает контейнер, удаляя все элементы из него.
 *
 * Этот метод освобождает память, занятую текущим внутренним деревом, и
 * создает новое пустое дерево для хранения элементов. Операция выполняется
 * без генерации исключений и помечена как noexcept, что указывает на отсутствие
 * исключений во время выполнения.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 */
template <typename Key> void set<Key>::clear() noexcept {
  // Освобождение памяти, занимаемой текущим деревом
  delete tree_;
  // Создание нового пустого дерева
  tree_ = new tree_type{};
}

/**
 * @brief Вставляет элемент в контейнер с уникальностью.
 *
 * Этот метод вставляет заданный элемент в контейнер типа set. Вставка
 * выполняется с условием уникальности, то есть, если элемент уже присутствует
 * в контейнере, он не будет вставлен, и метод вернет соответствующий итератор
 * на существующий элемент. Если элемент успешно вставлен, метод вернет итератор
 * на вставленный элемент и булево значение, указывающее на успешность вставки.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param value Значение для вставки в контейнер.
 * @return Пара, содержащая итератор на вставленный элемент и флаг успешности
 * вставки.
 */
template <typename Key>
std::pair<typename set<Key>::iterator, bool>
set<Key>::insert(const value_type &value) {
  // Вызов метода вставки с условием уникальности из внутреннего дерева
  return tree_->InsertUnique(value);
}

/**
 * @brief Удаляет элемент из контейнера по указанной позиции.
 *
 * Этот метод удаляет элемент из контейнера по указанной позиции, переданной
 * в качестве аргумента. Если позиция равна `end()`, то метод завершается
 * без выполнения каких-либо действий.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param position Итератор, указывающий на позицию удаляемого элемента.
 */
template <typename Key> void set<Key>::erase(iterator position) noexcept {
  // Проверка, является ли позиция итератором, указывающим за конец
  if (position == end()) {
    return; // Просто завершаем метод, не выполняя никаких действий
  }
  // Вызываем метод Erase из внутренней структуры данных
  tree_->Erase(position);
}

/**
 * @brief Удаляет элемент по заданному ключу из контейнера.
 *
 * Этот метод позволяет удалить элемент из контейнера по заданному ключу.
 * Сначала выполняется поиск элемента по ключу с использованием метода find().
 * Если элемент найден, он удаляется из контейнера с помощью метода erase() и
 * возвращается значение 1. Если элемент не найден, возвращается значение 0.
 *
 * @tparam Key Тип ключа, по которому производится поиск и удаление.
 * @param key Ключ элемента, который нужно удалить.
 * @return Количество удаленных элементов (0 или 1).
 */
template <typename Key>
typename set<Key>::size_type set<Key>::erase(const key_type &key) noexcept {
  // Поиск элемента по ключу
  auto it = find(key);
  if (it != end()) {
    // Удаление элемента
    erase(it);
    return 1;
  }
  return 0;
}
/**
 * @brief Обменивает содержимое двух контейнеров типа set.
 *
 * Этот метод позволяет обменять содержимое текущего контейнера с содержимым
 * переданного контейнера типа set. Обмен происходит путем обмена указателей
 * на внутренние структуры данных деревьев красно-черного типа.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param other Контейнер, с которым происходит обмен содержимым.
 */
template <typename Key> void set<Key>::swap(set &other) noexcept {
  tree_->Swap(*other.tree_);
}

/**
 * @brief Объединяет текущий контейнер с другим контейнером.
 *
 * Этот метод объединяет элементы текущего контейнера с элементами другого
 * переданного контейнера. При этом дублирующиеся элементы не добавляются.
 * Производится проверка на самоприсваивание, чтобы избежать некорректной
 * операции объединения с самим собой.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param other Другой контейнер, с которым выполняется объединение.
 */
template <typename Key> void set<Key>::merge(set &other) noexcept {
  // Проверка на самоприсваивание, чтобы избежать некорректной операции
  if (this == &other) {
    return; // Ничего не делаем при самоприсваивании
  }

  // Объединяем элементы из другого контейнера, исключая дубликаты
  tree_->MergeUnique(*other.tree_);

  // Очищаем элементы из другого контейнера
  other.clear();
}

/**
 * @brief Находит элемент по ключу в контейнере.
 *
 * Этот метод позволяет найти элемент в контейнере по заданному ключу.
 * В начале метода происходит проверка, существует ли вообще внутренний
 * объект-структура данных (дерево). Если объект не существует (равен nullptr),
 * то функция возвращает итератор, указывающий за конец контейнера. В противном
 * случае, происходит вызов соответствующего метода дерева (Find), который
 * выполняет поиск элемента в дереве.
 *
 * @param key Ключ, по которому нужно найти элемент.
 * @return Итератор на найденный элемент, либо итератор, указывающий за конец,
 * если элемент не найден или контейнер пуст.
 */
template <typename Key>
typename set<Key>::iterator set<Key>::find(const key_type &key) noexcept {
  // Проверяем, существует ли внутренний объект-структура данных
  if (!tree_) {
    return this->end();
  }

  // Вызываем метод поиска элемента в дереве
  return tree_->Find(key);
}

/**
 * @brief Находит элемент по ключу в контейнере (константная версия).
 *
 * Этот метод позволяет найти элемент в контейнере по заданному ключу.
 * Подобно не-константной версии метода, здесь также происходит проверка
 * наличия внутренней структуры данных (дерева). Если она не существует,
 * возвращается итератор, указывающий за конец контейнера. В противном случае,
 * вызывается соответствующий метод дерева (Find), который выполняет поиск
 * элемента в дереве.
 *
 * @param key Ключ, по которому нужно найти элемент.
 * @return Константный итератор на найденный элемент, либо константный
 * итератор, указывающий за конец, если элемент не найден или контейнер пуст.
 */
template <typename Key>
typename set<Key>::const_iterator
set<Key>::find(const key_type &key) const noexcept {
  // Проверяем, существует ли внутренний объект-структура данных
  if (!tree_) {
    return this->end();
  }

  // Вызываем метод поиска элемента в дереве
  return tree_->Find(key);
}

/**
 * @brief Возвращает количество вхождений элемента с заданным ключом в
 * контейнере.
 *
 * Этот метод проверяет, присутствует ли элемент с заданным ключом в контейнере
 * типа set. При наличии элемента возвращает 1, если элемент отсутствует -
 * возвращает 0.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @param key Ключ, для которого требуется подсчитать количество вхождений.
 * @return Количество вхождений элемента с заданным ключом.
 */
template <typename Key>
typename set<Key>::size_type
set<Key>::count(const key_type &key) const noexcept {
  // Проверяем, содержит ли контейнер элемент с заданным ключом
  return find(key) != end() ? 1 : 0;
}

/**
 * @brief Проверяет наличие элемента с заданным ключом в контейнере.
 *
 * Этот метод позволяет проверить, содержится ли элемент с заданным ключом
 * в контейнере. Для этого используется поиск элемента внутри внутреннего дерева
 * красно-черного типа. Если элемент с заданным ключом найден, метод возвращает
 * true, в противном случае возвращает false.
 *
 * @param key Ключ, который необходимо проверить на наличие в контейнере.
 * @return True, если элемент с указанным ключом найден в контейнере, иначе
 * false.
 */
template <typename Key>
bool set<Key>::contains(const key_type &key) const noexcept {
  // Получаем итератор, указывающий на конец контейнера
  auto end = tree_->End();

  // Проверяем, найден ли элемент с заданным ключом в контейнере
  return tree_->Find(key) != end;
}

/**
 * @brief Вставляет элемент с помощью конструктора в контейнер.
 *
 * Этот метод позволяет вставить элемент в контейнер, используя конструктор для
 * создания элемента. Метод принимает переменное число аргументов типа Args,
 * которые передаются конструктору элемента. Вставка осуществляется через
 * вызов метода EmplaceUnique внутренней структуры данных дерева красно-черного
 * типа.
 *
 * @tparam Args Типы аргументов, передаваемых в конструктор элемента.
 * @param args Аргументы, передаваемые в конструктор элемента.
 * @return Вектор пар итератор-булево, содержащий результаты вставки каждого
 * элемента.
 */
template <typename Key>
template <typename... Args>
std::vector<std::pair<typename set<Key>::iterator, bool>>
set<Key>::emplace(Args &&...args) {
  // Вызываем метод EmplaceUnique внутренней структуры данных с переданными
  // аргументами
  return tree_->EmplaceUnique(std::forward<Args>(args)...);
}

/**
 * @brief Вставляет несколько элементов из диапазона в контейнер.
 *
 * Этот метод вставляет элементы из диапазона [first, last) в контейнер типа
 * set. Для каждого элемента в диапазоне проверяется, успешно ли он вставлен в
 * контейнер. Если вставка прошла успешно (элемент не дублирует уже
 * существующий), счетчик успешных вставок увеличивается. По завершении вставки,
 * метод возвращает общее количество успешно вставленных элементов.
 *
 * @tparam Key Тип ключа, хранимого в контейнере.
 * @tparam InputIt Тип итератора для диапазона вставляемых элементов.
 * @param first Итератор, указывающий на первый элемент диапазона.
 * @param last Итератор, указывающий на элемент после последнего элемента
 * диапазона.
 * @return Количество успешно вставленных элементов.
 */
template <typename Key>
template <typename InputIt>
typename set<Key>::size_type set<Key>::insert_many(InputIt first,
                                                   InputIt last) noexcept {
  size_type count = 0; // Инициализация счетчика успешных вставок
  for (auto it = first; it != last; ++it) {
    auto result = insert(*it); // Вставка текущего элемента
    if (result.second) {
      ++count; // Увеличение счетчика, если вставка успешна
    }
  }
  return count; // Возврат общего количества успешно вставленных элементов
}

} // namespace s21
